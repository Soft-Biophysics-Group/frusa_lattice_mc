"""
Vincent Ouazan-Reboul, 2025
Functions to plot the results of simulations of cubic particles.
So far only supports one type of cubes.
"""

# pyright: basic

import config as cfg
from pathlib import Path
from geometry.cubic import CubicGeometry
import bpy
import shutil
import sys
import mathutils
import numpy as np
from geometry.cubic import CubicGeometry, CubicLattice, CubicParticle

path_to_config = Path(__file__).parent.parent

ALL_CONTACTS = [(i, j) for i in range(24) for j in range(24)]
DEFAULT_MATERIAL = (14, 0, 255, 0.1)

# Getting blender executable
blender_bin = shutil.which("Blender")
if blender_bin:
    print("Found:", blender_bin)
    bpy.app.binary_path = blender_bin
else:
    print("Unable to find blender!")

# Start from an empty scene
bpy.ops.wm.read_factory_settings(use_empty=True)

# Make sure we get the path to the cube
path_to_numbered_cube = (
    Path(__file__).parent / "assets/oneCube/one_cube_numbered.obj"
).resolve()
path_to_pm_cube = (
    Path(__file__).parent / "assets/oneCube/one_cube.obj"
    )
path_to_transparent_cube = (
    Path(__file__).parent / "assets/oneCube/one_cube_transparent.obj"
    )

# Code created with ChatGPT. Use with caution
def get_or_create_collection(collection_name="Squares"):
    """Check if a collection exists, if not, create it."""
    if collection_name in bpy.data.collections:
        return bpy.data.collections[collection_name]

    # Create a new collection and link it to the scene
    new_collection = bpy.data.collections.new(collection_name)
    bpy.context.scene.collection.children.link(new_collection)
    return new_collection


def plot_cube(
    coords=[0.0, 0.0, 0.0],
    euler_angles_xyz=[0.0, 0.0, 0.0],
    path_to_cube: Path | str = path_to_numbered_cube,
):
    """
    Puts an object (typically a decorated cube) located at path_to_cube at coordinates coords.
    Euler angles should be given in degrees.
    """
    bpy.ops.wm.obj_import(filepath=str(path_to_cube))
    cube = bpy.context.selected_objects[0]
    cube.location = coords
    new_rotation_euler = mathutils.Euler(euler_angles_xyz)
    cube.rotation_euler.rotate(new_rotation_euler)

    return cube


def plot_cube_from_site_orientation(
    site_index: int, orientation: int, lx: int, ly: int
):
    # The factor of 2 is due to the size of the cubes
    cubic_lattice = CubicGeometry(lx=lx, ly=ly).lattice
    site_coords = 2 * cubic_lattice.lattice_site_to_lattice_coords(site_index)
    rotation = CubicGeometry.particle.orientation_rotations[orientation]
    euler_angles = rotation.as_euler("xyz")

    plot_cube(site_coords, euler_angles)
    return

def plot_cubes_from_simulation_results(
    struct_index=-1,
    struct_folder="",
    struct_file="",
    model_file=cfg.default_model_params_file,
    fig_file = "",
    path_to_cube: Path | str = path_to_numbered_cube,
):
    params = cfg.load_model_file(model_file)
    lx = params["lx"]
    ly = params["ly"]
    results = cfg.load_structure(
        struct_index=struct_index, struct_folder=struct_folder, struct_file=struct_file
    )
    orientations = results[1, :]
    full_sites = cfg.get_full_sites(results)

    for site in full_sites:
        orientation = orientations[site]
        plot_cube_from_site_orientation(site, orientation, lx, ly)

    if fig_file:
        bpy.ops.wm.save_as_mainfile(filepath=fig_file)

    return

def clear_blender_fig():
    bpy.ops.object.select_all(action = 'SELECT')
    bpy.ops.object.delete()

    return


def save_blender_fig(blend_file_path: str | Path):
    bpy.ops.wm.save_as_mainfile(filepath=str(blend_file_path))


def create_material(name="CustomMaterial", color=DEFAULT_MATERIAL):
    """Create a new material with a given RGBA color (supports transparency).
    Generated by ChatGPT (I know, I know. I was in a rush)"""
    mat = bpy.data.materials.new(name=name)
    mat.use_nodes = True  # Enable node-based material

    # Get the Principled BSDF node
    bsdf = mat.node_tree.nodes.get("Principled BSDF")

    if bsdf:
        bsdf.inputs["Base Color"].default_value = color  # Set color & alpha
        bsdf.inputs["Alpha"].default_value = color[3]  # Set transparency

    # Enable transparency settings
    mat.blend_method = "BLEND"  # Enables alpha blending (smooth transparency)
    # mat.shadow_method = "HASHED"  # Ensures shadows work with transparency
    mat.use_backface_culling = False  # Show both sides

    return mat

def plot_square(
    face_cart_coords,
    bond_lattice_coords,
    lattice,
    material,
    size=2.0,
    collection_name="Squares",
):
    collection = get_or_create_collection(collection_name)

    half_size = size / 2
    # This is the center of the face.
    # ALong which direction of space is face oriented?
    face_dir = np.where(np.array(bond_lattice_coords) != 0)[0][0]
    other_dirs = [0, 1, 2]
    other_dirs.pop(face_dir)

    vertices = np.zeros((4,3))
    vertices[0, other_dirs[0]] += half_size
    vertices[0, other_dirs[1]] += half_size
    vertices[1, other_dirs[0]] += half_size
    vertices[1, other_dirs[1]] -= half_size
    vertices[2, other_dirs[0]] -= half_size
    vertices[2, other_dirs[1]] -= half_size
    vertices[3, other_dirs[0]] -= half_size
    vertices[3, other_dirs[1]] += half_size

    # Define faces (Blender uses quads)
    faces = [(0, 1, 2, 3)]
    edges = [(0, 1), (1, 2), (2, 3), (3, 0)]

    # Create a new mesh and object
    mesh = bpy.data.meshes.new(name="SquareMesh")
    obj = bpy.data.objects.new(name="Square", object_data=mesh)
    collection.objects.link(obj)
    bpy.context.collection.objects.link(obj)
    mesh.from_pydata(vertices, edges, faces)
    mesh.update()

    # Create an edge-only object
    edge_mesh = bpy.data.meshes.new(name="EdgeMesh")
    edge_obj = bpy.data.objects.new(name="Edges", object_data=edge_mesh)
    bpy.context.collection.objects.link(edge_obj)
    # Create edges as a separate mesh
    edge_mesh.from_pydata(vertices, edges, [])
    edge_mesh.update()

    # Move the object to the given location
    obj.location = face_cart_coords
    obj.data.materials.append(material)

    # Create edge material and assign it
    edge_color = (0.0, 0.0, 0.0, 1.0)
    edge_mat = create_material(name="EdgeMaterial", color=edge_color)
    edge_obj.data.materials.append(edge_mat)
    edge_obj.location = face_cart_coords

    return obj, edge_obj


def plot_grain_boundary(
    site_1,
    site_2,
    orientation_1,
    orientation_2,
    lattice,
    boundary_contacts,
    material,
    collection_name="Squares",
):
    # Get the coordinates of the face

    site_1_lattice_coords = lattice.lattice_site_to_lattice_coords(site_1)
    site_2_lattice_coords = lattice.lattice_site_to_lattice_coords(site_2)
    bond_lattice_coords = site_2_lattice_coords - site_1_lattice_coords
    # Case of periodic boundary conditions: put norm of bond back to 1
    # And invert its direction
    if np.abs(bond_lattice_coords.sum()) != 1.0:
        bond_lattice_coords //= -bond_lattice_coords.sum()
    bond_index = lattice.get_bond(bond_lattice_coords)
    face_1, face_2 = CubicParticle().get_faces_in_contact(
        orientation_1, orientation_2, bond_index
    )
    equiv_contacts = CubicParticle().get_equivalent_face_pairs(face_1, face_2)

    for equiv_face_1, equiv_face_2 in equiv_contacts:
        if (equiv_face_1, equiv_face_2) in boundary_contacts:
            site_1_coords = 2 * lattice.lattice_site_to_lattice_coords(site_1)
            # Factor of 2 is because of rescaling in blender
            face_cart_coords = site_1_coords + bond_lattice_coords
            plot_square(
                face_cart_coords,
                bond_lattice_coords,
                lattice,
                material,
                collection_name=collection_name,
            )

    return


def plot_all_grain_boundaries(
    boundary_contacts=ALL_CONTACTS,
    material=create_material(),
    struct_index=-1,
    struct_folder="",
    struct_file="",
    model_file=cfg.default_model_params_file,
    fig_file="",
    collection_name = "grain_boundaries"
):
    params = cfg.load_model_file(model_file)
    lx = params["lx"]
    ly = params["ly"]
    lz = params["lz"]
    lattice = CubicLattice(lx, ly, lz)

    results = cfg.load_structure(
        struct_index=struct_index, struct_folder=struct_folder, struct_file=struct_file
    )
    orientations = results[1, :]
    full_sites = cfg.get_full_sites(results)

    for site_1 in full_sites:
        orientation_1 = orientations[site_1]
        for site_2 in lattice.get_neighbour_sites(site_1):
            orientation_2 = orientations[site_2]
            plot_grain_boundary(
                site_1,
                site_2,
                orientation_1,
                orientation_2,
                lattice,
                boundary_contacts,
                material,
                collection_name = collection_name
            )

    if fig_file:
        bpy.ops.wm.save_as_mainfile(filepath=fig_file)

    return


# plot_cube(euler_angles_xyz=[1.57, 0, 0])
# plot_cube_from_site_orientation(1, 1, 10, 10)

# cube_struct_path = cfg.python_path / "examples/cubic/data/01_crystal/structures"
# plot_cubes_from_simulation_results(struct_folder=cube_struct_path)
# blend_file_path = "my_scene.blend"  # Replace with your desired path
# bpy.ops.wm.save_as_mainfile(filepath=blend_file_path)
